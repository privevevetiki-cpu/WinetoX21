-- LocalScript в StarterGui
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- Удаляем старый GUI
local oldGui = player:WaitForChild("PlayerGui"):FindFirstChild("SlapGUI")
if oldGui then oldGui:Destroy() end

-- === Создаём GUI ===
local gui = Instance.new("ScreenGui")
gui.Name = "SlapGUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- === Список слэпов ===
local slapList = {
    "Glitched Slap",
    "Nuclear Slap",
    "Ruby Slap",
    "Diamond Slap",
    "Iron Slap",
    "Bat"
}

local SelectedSlap = slapList[1]

-- === Кнопка открытия меню ===
local openBtn = Instance.new("TextButton")
openBtn.Size = UDim2.new(0, 180, 0, 40)
openBtn.Position = UDim2.new(0, 20, 0, 20)
openBtn.BackgroundTransparency = 0.5
openBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
openBtn.Text = "Select Slap"
openBtn.TextColor3 = Color3.fromRGB(255,255,255)
openBtn.TextScaled = true
openBtn.Font = Enum.Font.Arcade
openBtn.Parent = gui
Instance.new("UICorner", openBtn).CornerRadius = UDim.new(0, 8)

-- === Меню слэпов ===
local slapMenu = Instance.new("Frame")
slapMenu.Size = UDim2.new(0, 200, 0, #slapList*38 + 40)
slapMenu.Position = UDim2.new(0, 20, 0, 70)
slapMenu.BackgroundTransparency = 0.9
slapMenu.BackgroundColor3 = Color3.fromRGB(20,20,20)
slapMenu.Visible = false
slapMenu.Parent = gui
Instance.new("UICorner", slapMenu).CornerRadius = UDim.new(0, 12)

-- Заголовок
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 30)
title.BackgroundTransparency = 1
title.Text = "Select Slap"
title.TextColor3 = Color3.fromRGB(255,255,255)
title.TextScaled = true
title.Font = Enum.Font.Arcade
title.TextStrokeTransparency = 0.7
title.Parent = slapMenu

-- Кнопки слэпов
for i, slapName in ipairs(slapList) do
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.9, 0, 0, 32)
    btn.Position = UDim2.new(0.05, 0, 0, 30 + (i-1)*38)
    btn.BackgroundColor3 = (SelectedSlap == slapName) and Color3.fromRGB(0,170,0) or Color3.fromRGB(45,45,45)
    btn.BackgroundTransparency = 0.5
    btn.Text = slapName
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.TextScaled = true
    btn.Font = Enum.Font.Arcade
    btn.TextStrokeTransparency = 0.7
    btn.Parent = slapMenu
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

    btn.MouseButton1Click:Connect(function()
        SelectedSlap = slapName
        for _, child in ipairs(slapMenu:GetChildren()) do
            if child:IsA("TextButton") then
                child.BackgroundColor3 = (child.Text == SelectedSlap) and Color3.fromRGB(0,170,0) or Color3.fromRGB(45,45,45)
            end
        end
    end)
end

-- === Плавное открытие/закрытие меню ===
local menuOpen = false
openBtn.MouseButton1Click:Connect(function()
    menuOpen = not menuOpen
    slapMenu.Visible = true
    local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local goal = {}
    if menuOpen then
        goal.BackgroundTransparency = 0.3
    else
        goal.BackgroundTransparency = 0.9
    end
    local tween = TweenService:Create(slapMenu, tweenInfo, goal)
    tween:Play()
    tween.Completed:Connect(function()
        if not menuOpen then
            slapMenu.Visible = false
        end
    end)
end)

-- УДАЛЕНИЕ ПРЕДЫДУЩЕГО GUI, если уже есть
local oldGui = player:WaitForChild("PlayerGui"):FindFirstChild("LuaGUI")
if oldGui then oldGui:Destroy() end

-- === GUI ===
local gui = Instance.new("ScreenGui")
gui.Name = "LuaGUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- === ИКОНКА ===
local iconSize = 60
local icon = Instance.new("Frame")
icon.Size = UDim2.new(0, iconSize, 0, iconSize)
icon.Position = UDim2.new(0.075, 0, 0.38, 0)
icon.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
icon.BackgroundTransparency = 0.4
icon.BorderSizePixel = 0
icon.Parent = gui

local iconCorner = Instance.new("UICorner")
iconCorner.CornerRadius = UDim.new(1, 0)
iconCorner.Parent = icon

local iconStroke = Instance.new("UIStroke")
iconStroke.Thickness = 2
iconStroke.Transparency = 0.5
iconStroke.Color = Color3.fromRGB(255, 255, 255)
iconStroke.Parent = icon

local iconText = Instance.new("TextLabel")
iconText.Size = UDim2.new(1, 0, 1, 0)
iconText.BackgroundTransparency = 1
iconText.Text = "PvP 0.7.1"
iconText.TextScaled = true
iconText.Font = Enum.Font.Arcade
iconText.TextColor3 = Color3.fromRGB(255, 255, 255)
iconText.Parent = icon
-- === ДРАГ ДЛЯ ИКОНКИ ===
local dragging = false
local dragStart
local startPos

icon.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        dragging = true
        dragStart = input.Position
        startPos = icon.Position

        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

UserInputService.InputChanged:Connect(function(input)
    if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
        local delta = input.Position - dragStart
        icon.Position = UDim2.new(
            startPos.X.Scale, startPos.X.Offset + delta.X,
            startPos.Y.Scale, startPos.Y.Offset + delta.Y
        )
    end
end)


-- === ОКНО ===
local window = Instance.new("Frame")
window.Size = UDim2.new(0, 230, 0, 350)
window.Position = UDim2.new(0.5, 0, 0.5, 0)
window.AnchorPoint = Vector2.new(0.5, 0.5)
window.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
window.BackgroundTransparency = 0.15
window.Visible = false
window.Parent = gui

local winCorner = Instance.new("UICorner")
winCorner.CornerRadius = UDim.new(0.05, 0)
winCorner.Parent = window

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.Position = UDim2.new(0,0,0,0)
title.BackgroundTransparency = 1
title.Text = "PvP Menu Beta We need a good ping for the functions to work properly"
title.Font = Enum.Font.Arcade
title.TextScaled = true
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Parent = window

-- Контейнер для кнопок
local buttonsFrame = Instance.new("Frame")
buttonsFrame.Size = UDim2.new(1, 0, 1, -40)
buttonsFrame.Position = UDim2.new(0, 0, 0, 40)
buttonsFrame.BackgroundTransparency = 1
buttonsFrame.Parent = window

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 6)
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
layout.VerticalAlignment = Enum.VerticalAlignment.Top
layout.Parent = buttonsFrame

-- === Вспомогательные таблицы ===
local buttons = {}        -- кнопки (TextButton)
local bindBoxes = {}      -- TextBox для биндов (только Big Ragdoll и Near Player)
local binds = {           -- хранение биндов (строка)
    ["Big Ragdoll 0.5"] = "",
    ["Near Player 1.3"] = ""
}

-- создать строку: кнопка + bind box (если нужно)
local function makeButtonRow(name, showBind)
    local row = Instance.new("Frame")
    row.Size = UDim2.new(0.95, 0, 0, 28)
    row.BackgroundTransparency = 1
    row.Parent = buttonsFrame

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.74, 0, 1, 0)
    btn.Position = UDim2.new(0, 0, 0, 0)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    btn.AutoButtonColor = false
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.TextScaled = true
    btn.Font = Enum.Font.Arcade
    btn.Text = name
    btn.Parent = row

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.18,0)
    corner.Parent = btn

    local bindBox = nil
    if showBind then
        bindBox = Instance.new("TextBox")
        bindBox.Size = UDim2.new(0.24, 0, 1, 0)
        bindBox.Position = UDim2.new(0.76, 0, 0, 0)
        bindBox.BackgroundColor3 = Color3.fromRGB(35,35,35)
        bindBox.TextColor3 = Color3.fromRGB(255,255,255)
        bindBox.ClearTextOnFocus = true
        bindBox.PlaceholderText = "Bind"
        bindBox.Font = Enum.Font.Arcade
        bindBox.TextScaled = true
        bindBox.Text = binds[name] or ""
        bindBox.Parent = row

        local bcorner = Instance.new("UICorner")
        bcorner.CornerRadius = UDim.new(0.18,0)
        bcorner.Parent = bindBox
    else
        -- пустая заплатка чтобы layout не ломался
        local spacer = Instance.new("Frame")
        spacer.Size = UDim2.new(0.24, 0, 1, 0)
        spacer.BackgroundTransparency = 1
        spacer.Position = UDim2.new(0.76, 0, 0, 0)
        spacer.Parent = row
    end

    return btn, bindBox
end

local buttonNames = {
    "HitBox Visible 0.4",
    "Speed Booster 0.3",
    "Big Ragdoll 0.5",
    "Near Player 1.3",
    "Auto Grab 0.2(NO WORK)",
    "Show Hitboxes 0.2",
    "Visible ping",
    "Button 8",
    "Button 9"
}

for _, name in ipairs(buttonNames) do
    local showBind = (name == "Big Ragdoll 0.5" or name == "Near Player 1.3")
    local btn, tb = makeButtonRow(name, showBind)
    buttons[name] = btn
    if tb then bindBoxes[name] = tb end
end

-- helper: визуализация статуса кнопки (зелёный = включено)
local function setButtonActiveVisual(name, on)
    local b = buttons[name]
    if not b then return end
    if on then
        b.BackgroundColor3 = Color3.fromRGB(0,170,0)
    else
        b.BackgroundColor3 = Color3.fromRGB(40,40,40)
    end
end

-- === SLAP MENU (кнопка слева от Near Player + выезжающее меню) ===
do
    -- список слэпов (имена моделей в Backpack/Character)
    local slapList = {
        "Glitched Slap",
        "Nuclear Slap",
        "Ruby Slap",
        "Diamod Slap",
        "Iron Slap",
        "Bat"
    }

    -- создаём маленькую кнопку, прилеплённую к строке Near Player
    local nearRowBtn = buttons["Near Player 1.2"]
    if nearRowBtn then
        local slapMenuButton = Instance.new("TextButton")
        slapMenuButton.Name = "SlapMenuBtn"
        slapMenuButton.Size = UDim2.new(0, 22, 0, 22)
        slapMenuButton.Position = UDim2.new(1, 6, 0.5, -11) -- справа от кнопки, но we'll position relative to window later
        slapMenuButton.AnchorPoint = Vector2.new(0, 0)
        slapMenuButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
        slapMenuButton.Text = "≡"
        slapMenuButton.TextScaled = true
        slapMenuButton.Font = Enum.Font.Arcade
        slapMenuButton.TextColor3 = Color3.fromRGB(255,255,255)
        slapMenuButton.Parent = nearRowBtn
    end

    -- плавающее меню (отдельное окно, не на window)
    local slapWindow = Instance.new("Frame")
    slapWindow.Name = "SlapWindow"
    slapWindow.Size = UDim2.new(0, 180, 0, 220)
    -- позиционируем чуть левее основного окна
    local windowScreenPos = window.AbsolutePosition
    slapWindow.Position = UDim2.new(0, windowScreenPos.X - 200, 0, windowScreenPos.Y)
    slapWindow.BackgroundColor3 = Color3.fromRGB(25,25,25)
    slapWindow.BorderSizePixel = 0
    slapWindow.Visible = false
    slapWindow.Parent = gui

    local swCorner = Instance.new("UICorner")
    swCorner.CornerRadius = UDim.new(0.05, 0)
    swCorner.Parent = slapWindow

    local swStroke = Instance.new("UIStroke")
    swStroke.Color = Color3.fromRGB(255,255,255)
    swStroke.Transparency = 0.85
    swStroke.Thickness = 1
    swStroke.Parent = slapWindow

    local header = Instance.new("TextLabel")
    header.Size = UDim2.new(1, 0, 0, 30)
    header.Position = UDim2.new(0,0,0,0)
    header.BackgroundTransparency = 1
    header.Text = "Slap Selector"
    header.Font = Enum.Font.Arcade
    header.TextSize = 16
    header.TextColor3 = Color3.fromRGB(255,255,255)
    header.Parent = slapWindow

    local listFrame = Instance.new("Frame")
    listFrame.Size = UDim2.new(1, -10, 1, -40)
    listFrame.Position = UDim2.new(0, 5, 0, 35)
    listFrame.BackgroundTransparency = 1
    listFrame.Parent = slapWindow

    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, 6)
    listLayout.FillDirection = Enum.FillDirection.Vertical
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    listLayout.Parent = listFrame

    local function refreshSlapButtonsVisual()
        for _, c in ipairs(listFrame:GetChildren()) do
            if c:IsA("TextButton") then
                if c.Name == SelectedSlap then
                    c.BackgroundColor3 = Color3.fromRGB(0,170,0)
                    c.TextColor3 = Color3.fromRGB(0,0,0)
                else
                    c.BackgroundColor3 = Color3.fromRGB(40,40,40)
                    c.TextColor3 = Color3.fromRGB(255,255,255)
                end
            end
        end
    end

    for _, name in ipairs(slapList) do
        local b = Instance.new("TextButton")
        b.Name = name
        b.Size = UDim2.new(0, 160, 0, 32)
        b.BackgroundColor3 = Color3.fromRGB(40,40,40)
        b.Font = Enum.Font.Arcade
        b.TextScaled = true
        b.Text = name
        b.Parent = listFrame

        local bc = Instance.new("UICorner")
        bc.CornerRadius = UDim.new(0.12, 0)
        bc.Parent = b

        b.MouseEnter:Connect(function()
            if b.Name ~= SelectedSlap then
                b:TweenSize(UDim2.new(0, 164, 0, 34), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.08, true)
                b.BackgroundColor3 = Color3.fromRGB(55,55,55)
            end
        end)
        b.MouseLeave:Connect(function()
            if b.Name ~= SelectedSlap then
                b:TweenSize(UDim2.new(0, 160, 0, 32), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.08, true)
                b.BackgroundColor3 = Color3.fromRGB(40,40,40)
            end
        end)

        b.MouseButton1Click:Connect(function()
            SelectedSlap = name
            refreshSlapButtonsVisual()
        end)
    end

    -- make slapWindow draggable (custom)
    do
        local dragging = false
        local dragStart = Vector2.new()
        local startPos = slapWindow.Position

        slapWindow.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = slapWindow.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                slapWindow.Position = UDim2.new(
                    startPos.X.Scale, startPos.X.Offset + delta.X,
                    startPos.Y.Scale, startPos.Y.Offset + delta.Y
                )
            end
        end)
    end

    -- toggle animation (show/hide)
    local menuOpen = false
    if nearRowBtn and nearRowBtn:FindFirstChild("SlapMenuBtn") then
        local trigger = nearRowBtn:FindFirstChild("SlapMenuBtn")
        trigger.MouseButton1Click:Connect(function()
            menuOpen = not menuOpen
            if menuOpen then
                slapWindow.Visible = true
                -- move to near the main window but slightly left
                local target = UDim2.new(0, window.AbsolutePosition.X - slapWindow.Size.X.Offset - 12, 0, window.AbsolutePosition.Y)
                slapWindow:TweenPosition(target, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true)
            else
                slapWindow:TweenPosition(UDim2.new(0, -1000, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.22, true)
                task.delay(0.22, function() slapWindow.Visible = false end)
            end
        end)
    end
end

-- === HITBOX Visible + NearPlayer зона (один прямоугольник) ===
do
    local PlayersSvc = Players
    local Local = player
    local hitboxVisible = false

    -- NearPlayer зона
    local nearPart

    -- создание обычного хитбокса и подсветки
    local function createHitboxESP(char)
        local hitbox = char:FindFirstChild("__HITBOX")
        if hitbox and hitbox:IsA("BasePart") then
            if not hitbox:FindFirstChild("HitboxHighlight") then
                local hl = Instance.new("Highlight")
                hl.Name = "HitboxHighlight"
                hl.Adornee = hitbox
                hl.FillColor = Color3.fromRGB(0,0,0)
                hl.OutlineColor = Color3.fromRGB(255,255,255)
                hl.FillTransparency = 0.5
                hl.OutlineTransparency = 0
                hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                hl.Parent = hitbox
            end
            hitbox.Transparency = 0.5
            hitbox.CanCollide = false
        end
    end

    -- обновление всех хитбоксов
    local function updateHitboxes()
        for _, plr in ipairs(PlayersSvc:GetPlayers()) do
            if plr ~= Local and plr.Character then
                createHitboxESP(plr.Character)
            end
        end
    end

    -- toggle кнопка
    local toggleBtn = buttons["HitBox Visible 0.4"]
    toggleBtn.MouseButton1Click:Connect(function()
        hitboxVisible = not hitboxVisible
        if hitboxVisible then
            updateHitboxes()
        else
            if nearPart then nearPart:Destroy() nearPart = nil end
        end
        setButtonActiveVisual("HitBox Visible 0.4", hitboxVisible)
    end)
    setButtonActiveVisual("HitBox Visible 0.4", false)

    -- Heartbeat для динамики NearPlayer зоны
    RunService.Heartbeat:Connect(function()
        if hitboxVisible then
            -- try to call updateNearHitbox if exists
            pcall(function() if updateNearHitbox then updateNearHitbox() end end)
        end
    end)

    -- автоматическое добавление при появлении нового игрока
    PlayersSvc.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(function()
            task.wait(0.5)
            if hitboxVisible then
                updateHitboxes()
            end
        end)
    end)
end

-- === Speed Booster ===
do
    local speedBtn = buttons["Speed Booster 0.3"]
    local speedActive = false
    local speedConn = nil
    local baseSpeed = 27

    local function getChar()
        return player.Character
    end

    local function startSpeed()
        if speedConn then return end
        speedConn = RunService.Heartbeat:Connect(function()
            local char = getChar()
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum then return end
            local move = hum.MoveDirection
            if move.Magnitude > 0.01 then
                hrp.AssemblyLinearVelocity = Vector3.new(move.Unit.X*baseSpeed, hrp.AssemblyLinearVelocity.Y, move.Unit.Z*baseSpeed)
            else
                hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
            end
        end)
    end

    local function stopSpeed()
        if speedConn then speedConn:Disconnect() speedConn = nil end
        local char = getChar()
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
        end
    end

    speedBtn.MouseButton1Click:Connect(function()
        speedActive = not speedActive
        if speedActive then
            startSpeed()
        else
            stopSpeed()
        end
        setButtonActiveVisual("Speed Booster 0.3", speedActive)
    end)
    setButtonActiveVisual("Speed Booster 0.3", false)
end

-- === Перетаскивание окна (таскается за любую часть окна) ===
do
    local dragging = false
    local dragStart = Vector2.new()
    local startPos = window.Position

    window.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = window.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            window.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

---------------------------------------------------------
-- === Big Ragdoll логика (удар взят из Near Player) ===
---------------------------------------------------------

local bigEnabled = false
local bigBtn = buttons["Big Ragdoll 0.5"]

local lastBigHit = 0

---------------------------------------------------------
--  Функция удара
---------------------------------------------------------
local function performRagdollHit()
    local now = tick()
    if now - lastBigHit < 0.8 then return end
    lastBigHit = now

    local character = player.Character
    if not character then return end

    local backpack = player:FindFirstChild("Backpack") or player:WaitForChild("Backpack")

    ---------------------------------------------------------
    --  УДАР (взято из hitNearbyInvisible)
    ---------------------------------------------------------
    local bat = backpack:FindFirstChild("Bat") or character:FindFirstChild("Bat")
    local glitch = backpack:FindFirstChild(SelectedSlap) or character:FindFirstChild(SelectedSlap)

    if not bat or not glitch then return end

    glitch.Parent = character

    if glitch:FindFirstChild("Activate") then
        glitch.Activate:Fire()
    else
        pcall(function()
            glitch:Activate()
        end)
    end

    glitch.Parent = backpack

    if bat.Parent ~= character then
        bat.Parent = character
    end
end


---------------------------------------------------------
--  Проверка подавления Near Player
---------------------------------------------------------
local function isNearPlayerSuppressing()
    local nearBtn = buttons["Near Player 1.3"]
    if not nearBtn then return false end

    return nearBtn.BackgroundColor3 == Color3.fromRGB(0,170,0)
end


---------------------------------------------------------
--  Кнопка включения Big Ragdoll
---------------------------------------------------------
bigBtn.MouseButton1Click:Connect(function()
    bigEnabled = not bigEnabled
    setButtonActiveVisual("Big Ragdoll 0.5", bigEnabled)

    ---------------------------------------------------------
    --  ЕСЛИ Big Ragdoll ВЫКЛЮЧЕН — ВЕРНУТЬ НАСТОЯЩИЙ BAT
    ---------------------------------------------------------
    if not bigEnabled then
        local character = player.Character
        if not character then return end

        local backpack = player:FindFirstChild("Backpack") or player:WaitForChild("Backpack")

        -- находим обычный bat
        local realBat = backpack:FindFirstChild("Bat") or character:FindFirstChild("Bat")
        if realBat then
            realBat.Parent = character
        end
    end
end)


---------------------------------------------------------
--  Клик мыши
---------------------------------------------------------
local mouse = player:GetMouse()

mouse.Button1Down:Connect(function()
    if bigEnabled and not isNearPlayerSuppressing() then
        performRagdollHit()
    end
end)

-- Лаг-компенсация позиции игрока
local function GetPredictedPosition(character)
    if not character then return nil end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    -- текущее движение
    local vel = hrp.AssemblyLinearVelocity  

    -- твой реальный пинг
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000  
    -- ping 120 = 0.12 сек

    -- предсказанная позиция
    local predicted = hrp.Position + vel * ping

    return predicted
end
-- === Near Player + 2 хитбокса (трапеция) + отдельная кнопка Show Hitboxes ===

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local nearEnabled = false
local showHitboxes = false

-- кнопки
local nearBtn = buttons["Near Player 1.3"]
local showBtn = buttons["Show Hitboxes 0.2"]  -- ОТДЕЛЬНАЯ КНОПКА

local lastNearHit = 0

local partFront
local partBack

local FRONT_SIZE = Vector3.new(10, 10, 8)
local BACK_SIZE  = Vector3.new(6, 10, 6)


---------------------------------------------------------
--                УДАР ПО ИГРОКУ
---------------------------------------------------------
local function hitNearbyInvisible(plr)
    local now = tick()
    if now - lastNearHit < 0.8 then return end
    lastNearHit = now

    local char = player.Character
    local targetChar = plr.Character
    if not char or not targetChar then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")

    if not hrp or not humanoid or not targetHRP then return end

    -- поворот (фиксим ShiftLock)
    local dir = (targetHRP.Position - hrp.Position)
    local yaw = math.atan2(-dir.X, -dir.Z)

    local oldCF = hrp.CFrame
    humanoid.AutoRotate = false
    hrp.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, yaw, 0)

    -- Слап
    local backpack = player.Backpack
    local bat = backpack:FindFirstChild("Bat") or char:FindFirstChild("Bat")
    local glitch = backpack:FindFirstChild(SelectedSlap) or char:FindFirstChild(SelectedSlap)
    if not bat or not glitch then return end

    glitch.Parent = char
    if glitch:FindFirstChild("Activate") then
        glitch.Activate:Fire()
    else
        pcall(function() glitch:Activate() end)
    end
    glitch.Parent = backpack

    if bat.Parent ~= char then
        bat.Parent = char
    end

    -- вернуть поворот
    task.delay(0.05, function()
        if humanoid and hrp then
            hrp.CFrame = oldCF
            humanoid.AutoRotate = true
        end
    end)
end


---------------------------------------------------------
--             СОЗДАНИЕ ХИТБОКСОВ
---------------------------------------------------------
local function createParts()
    if not partFront then
        partFront = Instance.new("Part")
        partFront.Anchored = true
        partFront.CanCollide = false
        partFront.CanQuery = false
        partFront.Size = FRONT_SIZE
        partFront.Material = Enum.Material.Neon
        partFront.Color = Color3.fromRGB(0,255,0)
        partFront.Transparency = 1
        partFront.Parent = workspace
    end

    if not partBack then
        partBack = Instance.new("Part")
        partBack.Anchored = true
        partBack.CanCollide = false
        partBack.CanQuery = false
        partBack.Size = BACK_SIZE
        partBack.Material = Enum.Material.Neon
        partBack.Color = Color3.fromRGB(0,180,0)
        partBack.Transparency = 1
        partBack.Parent = workspace
    end
end


---------------------------------------------------------
--            ОБНОВЛЕНИЕ ПОЗИЦИЙ ХИТБОКСОВ
---------------------------------------------------------
local function updateParts()
    if not nearEnabled then
        if partFront then partFront:Destroy() partFront = nil end
        if partBack then partBack:Destroy() partBack = nil end
        return
    end

    createParts()

    local char = player.Character
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local forward = hrp.CFrame.LookVector

    -- маленький спереди
    partFront.CFrame = CFrame.new(
        hrp.Position + forward * 3,
        hrp.Position + forward * 50
    )

    -- большой сзади
    partBack.CFrame = CFrame.new(
        hrp.Position + forward * 7,
        hrp.Position + forward * 50
    )
end


---------------------------------------------------------
--               ПОКАЗ / СКРЫТИЕ ХИТБОКСОВ
---------------------------------------------------------
local function updateHitboxVisibility()
    if partFront then
        partFront.Transparency = showHitboxes and 0.3 or 1
    end

    if partBack then
        partBack.Transparency = showHitboxes and 0.3 or 1
    end
end


---------------------------------------------------------
--                 ПРОВЕРКА ИГРОКОВ
---------------------------------------------------------
local function checkZone(plr, zonePart)
    local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    local pos = hrp.Position
    local cf = zonePart.CFrame
    local size = zonePart.Size / 2

    local rel = cf:PointToObjectSpace(pos)

    return (
        math.abs(rel.X) <= size.X and
        math.abs(rel.Y) <= size.Y and
        math.abs(rel.Z) <= size.Z
    )
end

local function checkPlayers()
    if not nearEnabled then return end
    if not partFront and not partBack then return end

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            if (partFront and checkZone(pl, partFront))
            or (partBack and checkZone(pl, partBack)) then
                hitNearbyInvisible(pl)
            end
        end
    end
end


---------------------------------------------------------
--                   КНОПКИ
---------------------------------------------------------
nearBtn.MouseButton1Click:Connect(function()
    nearEnabled = not nearEnabled
    setButtonActiveVisual("Near Player 1.3", nearEnabled)

    if not nearEnabled then
        if partFront then partFront:Destroy() partFront = nil end
        if partBack then partBack:Destroy() partBack = nil end
    end
end)

showBtn.MouseButton1Click:Connect(function()
    showHitboxes = not showHitboxes
    setButtonActiveVisual("Show Hitboxes 0.2", showHitboxes)
    updateHitboxVisibility()
end)


---------------------------------------------------------
--                 HEARTBEAT
---------------------------------------------------------
RunService.Heartbeat:Connect(function()
    if nearEnabled then
        updateParts()
        checkPlayers()
    end

    updateHitboxVisibility()
end)

-- === BIND handling (TextBoxes + Enter to set / key toggles) ===
do
    local typing = false
    local activeTextBox = nil

    local function normalizeBindText(s)
        if not s then return "" end
        s = tostring(s):gsub("^%s*(.-)%s*$", "%1") -- trim
        return s:upper()
    end

    -- Setup TextBoxes behavior
    for name, tb in pairs(bindBoxes) do
        tb.FocusLost:Connect(function(enterPressed)
            typing = false
            activeTextBox = nil
            if enterPressed then
                local txt = normalizeBindText(tb.Text)
                -- принять пустой – очистить
                binds[name] = txt
                tb.Text = txt
            else
                tb.Text = binds[name] or ""
            end
        end)

        tb.Focused:Connect(function()
            typing = true
            activeTextBox = tb
            tb.Text = ""
        end)
    end

    -- НАДЁЖНОЕ InputBegan без глюков
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if typing then return end
        if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

        -- ЧИСТОЕ ИМЯ КЛАВИШИ
        local keyName = input.KeyCode.Name:upper()
        if not keyName or keyName == "" then return end

        -- Перебираем все действия
        for actionName, bindStr in pairs(binds) do
            if bindStr and bindStr ~= "" then
                local norm = normalizeBindText(bindStr)

                -- Чёткое совпадение
                if norm == keyName then
                    if actionName == "Big Ragdoll 0.5" then
                        bigEnabled = not bigEnabled
                        setButtonActiveVisual("Big Ragdoll 0.5", bigEnabled)

                    elseif actionName == "Near Player 1.3" then
                        nearEnabled = not nearEnabled
                        setButtonActiveVisual("Near Player 1.3", nearEnabled)
                    end
                end
            end
        end
    end)
end

-- === Инициализация визуалок (везде нейтральный цвет, активные будут зелёными) ===
for name, btn in pairs(buttons) do
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
end
setButtonActiveVisual("HitBox Visible 0.4", false)
setButtonActiveVisual("Speed Booster 0.3", false)
setButtonActiveVisual("Big Ragdoll 0.5", false)
setButtonActiveVisual("Near Player 1.3", false)

-- === Иконка и открытие окна ===
icon.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        -- toggle window visibility
        if window.Visible then
            window:TweenSizeAndPosition(UDim2.new(0,0,0,0), window.Position, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.18, true)
            task.wait(0.18)
            window.Visible = false
        else
            window.Visible = true
            window.Size = UDim2.new(0,0,0,0)
            window:TweenSizeAndPosition(UDim2.new(0,230,0,300), UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.22, true)
        end
    end
end)

-- RightShift toggle also works
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.RightShift then
        if window.Visible then
            window:TweenSizeAndPosition(UDim2.new(0,0,0,0), window.Position, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.18, true)
            task.wait(0.18)
            window.Visible = false
        else
            window.Visible = true
            window.Size = UDim2.new(0,0,0,0)
            window:TweenSizeAndPosition(UDim2.new(0,230,0,300), UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.22, true)
        end
    end
end)
-- Улучшенный и диагностируемый AutoGrab (клиент) с телепортом Spawn к игроку и возвратом
local autoGrab = false
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local PromptService = game:GetService("ProximityPromptService")
local lp = Players.LocalPlayer

local DEBUG = true
local function dbg(...)
	if DEBUG then
		print("[AutoGrab]", ...)
	end
end

local function getCharacter()
	local char = lp.Character or lp.CharacterAdded:Wait()
	local hrp = char:FindFirstChild("HumanoidRootPart")
	if not hrp then
		hrp = char:WaitForChild("HumanoidRootPart", 5)
	end
	return char, hrp
end

if buttons and buttons["Auto Grab 0.2(NO WORK)"] then
	buttons["Auto Grab 0.2(NO WORK)"].MouseButton1Click:Connect(function()
		autoGrab = not autoGrab
		setButtonActiveVisual("Auto Grab 0.2(NO WORK)", autoGrab)
		dbg("AutoGrab toggled:", autoGrab)
	end)
else
	lp:GetMouse().KeyDown:Connect(function(key)
		if key == "r" then
			autoGrab = not autoGrab
			dbg("AutoGrab toggled by R:", autoGrab)
		end
	end)
end

local function safeTrigger(prompt)
	task.wait(0.08 + math.random() * 0.06)
	local ok, err = pcall(function()
		PromptService:TriggerPrompt(prompt, lp)
	end)
	if ok then
		dbg("TriggerPrompt OK for", prompt:GetFullName())
		return true
	else
		warn("[AutoGrab] TriggerPrompt failed:", err, " — fallback InputHold.")
		local ok2, err2 = pcall(function()
			if not prompt or not prompt.Parent or not prompt:IsA("ProximityPrompt") then
				error("prompt invalid for fallback")
			end
			local hold = prompt.HoldDuration or 0.8
			prompt:InputHoldBegin()
			task.wait(math.max(0.05, math.min(hold, 2)))
			prompt:InputHoldEnd()
		end)
		if ok2 then
			dbg("Fallback InputHold succeeded for", prompt:GetFullName())
			return true
		else
			warn("[AutoGrab] Fallback failed:", err2)
			return false
		end
	end
end

RunService.Heartbeat:Connect(function()
	if not autoGrab then return end

	local char, hrp = getCharacter()
	if not hrp then return end

	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		local podiums = plot:FindFirstChild("AnimalPodiums")
		local promptList = {}

		if not podiums then
			promptList = plot:GetDescendants()
		else
			for _, podium in ipairs(podiums:GetChildren()) do
				local base = podium:FindFirstChild("Base") or podium
				local spawnPart = base:FindFirstChild("Spawn") or base
				table.move(spawnPart:GetDescendants(), 1, #spawnPart:GetDescendants(), #promptList + 1, promptList)
			end
		end

		for _, obj in ipairs(promptList) do
			if obj:IsA("ProximityPrompt") and obj.Enabled and string.lower(tostring(obj.ActionText)) == "steal" then
				local promptPos
				local pParent = obj.Parent
				if pParent and pParent:IsA("BasePart") then
					promptPos = pParent.Position
				elseif pParent and pParent:IsA("Attachment") and pParent.Parent and pParent.Parent:IsA("BasePart") then
					promptPos = pParent.Parent.Position
				end
				if promptPos then
					local dist = (hrp.Position - promptPos).Magnitude

					-- телепорт Spawn к игроку, если вне зоны
					if dist > obj.MaxActivationDistance then
						local spawnObj = obj.Parent
						if spawnObj:IsA("Attachment") and spawnObj.Parent:IsA("BasePart") then
							spawnObj = spawnObj.Parent
						end
						if spawnObj:IsA("BasePart") then
							local originalCFrame = spawnObj.CFrame
							local offset = Vector3.new(0,3,0)
							spawnObj.CFrame = CFrame.new(hrp.Position + offset)
							dbg("Teleported Spawn to player for prompt:", obj:GetFullName())

							-- через 0.2 сек возвращаем на место
							task.spawn(function()
								task.wait(0.2)
								if spawnObj and spawnObj.Parent then
									spawnObj.CFrame = originalCFrame
									dbg("Returned Spawn back for prompt:", obj:GetFullName())
								end
							end)
						end
					end

					task.spawn(function()
						safeTrigger(obj)
					end)
				end
			end
		end
	end
end)
-- === PING GUI ===
local pingEnabled = false

local pingFrame = Instance.new("Frame")
pingFrame.Size = UDim2.new(0, 200, 0, 80)
pingFrame.Position = UDim2.new(1, -220, 0, 20)
pingFrame.BackgroundColor3 = Color3.fromRGB(20,20,20)
pingFrame.BackgroundTransparency = 0.6
pingFrame.Visible = false
pingFrame.Parent = gui
Instance.new("UICorner", pingFrame)

-- основной текст пинга
local pingText = Instance.new("TextLabel")
pingText.Size = UDim2.new(1,0,0.6,0)
pingText.BackgroundTransparency = 1
pingText.Font = Enum.Font.Arcade
pingText.TextScaled = true
pingText.TextColor3 = Color3.fromRGB(255,255,255)
pingText.Text = "Ping: 0"
pingText.Parent = pingFrame

-- индикатор качества
local statusText = Instance.new("TextLabel")
statusText.Size = UDim2.new(1,0,0.4,0)
statusText.Position = UDim2.new(0,0,0.6,0)
statusText.BackgroundTransparency = 1
statusText.Font = Enum.Font.Arcade
statusText.TextScaled = true
statusText.TextColor3 = Color3.fromRGB(0,255,0)
statusText.Text = "Good"
statusText.Parent = pingFrame

-- перетаскивание
do
    local dragging = false
    local dragStart = Vector2.new()
    local startPos

    pingFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = pingFrame.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            pingFrame.Position = UDim2.new(
                startPos.X.Scale, startPos.X.Offset + delta.X,
                startPos.Y.Scale, startPos.Y.Offset + delta.Y
            )
        end
    end)
end

-- автоматическое обновление пинга
task.spawn(function()
    while true do
        task.wait(0.5)

        if pingEnabled then
            local ping = math.clamp(Players.LocalPlayer:GetNetworkPing() * 1000, 0, 250)
            ping = math.floor(ping)

            pingText.Text = "Ping: " .. ping

            if ping <= 99 then
                statusText.Text = "Good"
                statusText.TextColor3 = Color3.fromRGB(0,255,0)

            elseif ping <= 159 then
                statusText.Text = "Normal"
                statusText.TextColor3 = Color3.fromRGB(255,140,0)

            else
                statusText.Text = "Badly"
                statusText.TextColor3 = Color3.fromRGB(255,0,0)
            end
        end
    end
end)

-- кнопка включения
buttons["Visible ping"].MouseButton1Click:Connect(function()
    pingEnabled = not pingEnabled
    pingFrame.Visible = pingEnabled
    setButtonActiveVisual("Visible ping", pingEnabled)
end)
