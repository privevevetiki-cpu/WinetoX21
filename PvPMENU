-- LocalScript в StarterGui
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")

local player = Players.LocalPlayer

-- Удаляем старый GUI
local oldGui = player:WaitForChild("PlayerGui"):FindFirstChild("SlapGUI")
if oldGui then oldGui:Destroy() end

-- === Создаём GUI ===
local gui = Instance.new("ScreenGui")
gui.Name = "SlapGUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- === Список слэпов ===
local slapList = {
    "Glitched Slap",
    "Nuclear Slap",
    "Ruby Slap",
    "Diamond Slap",
    "Iron Slap",
    "Bat"
}

local SelectedSlap = slapList[1]

-- === Кнопка открытия меню ===
local openBtn = Instance.new("TextButton")
openBtn.Size = UDim2.new(0, 180, 0, 40)
openBtn.Position = UDim2.new(0, 20, 0, 20)
openBtn.BackgroundTransparency = 0.5
openBtn.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
openBtn.Text = "Select Slap"
openBtn.TextColor3 = Color3.fromRGB(255,255,255)
openBtn.TextScaled = true
openBtn.Font = Enum.Font.Arcade
openBtn.Parent = gui
Instance.new("UICorner", openBtn).CornerRadius = UDim.new(0, 8)

-- === Меню слэпов ===
local slapMenu = Instance.new("Frame")
slapMenu.Size = UDim2.new(0, 200, 0, #slapList*38 + 40)
slapMenu.Position = UDim2.new(0, 20, 0, 70)
slapMenu.BackgroundTransparency = 0.9
slapMenu.BackgroundColor3 = Color3.fromRGB(20,20,20)
slapMenu.Visible = false
slapMenu.Parent = gui
Instance.new("UICorner", slapMenu).CornerRadius = UDim.new(0, 12)

-- Заголовок
local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 30)
title.BackgroundTransparency = 1
title.Text = "Select Slap"
title.TextColor3 = Color3.fromRGB(255,255,255)
title.TextScaled = true
title.Font = Enum.Font.Arcade
title.TextStrokeTransparency = 0.7
title.Parent = slapMenu

-- Кнопки слэпов
for i, slapName in ipairs(slapList) do
    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.9, 0, 0, 32)
    btn.Position = UDim2.new(0.05, 0, 0, 30 + (i-1)*38)
    btn.BackgroundColor3 = (SelectedSlap == slapName) and Color3.fromRGB(0,170,0) or Color3.fromRGB(45,45,45)
    btn.BackgroundTransparency = 0.5
    btn.Text = slapName
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.TextScaled = true
    btn.Font = Enum.Font.Arcade
    btn.TextStrokeTransparency = 0.7
    btn.Parent = slapMenu
    Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

    btn.MouseButton1Click:Connect(function()
        SelectedSlap = slapName
        for _, child in ipairs(slapMenu:GetChildren()) do
            if child:IsA("TextButton") then
                child.BackgroundColor3 = (child.Text == SelectedSlap) and Color3.fromRGB(0,170,0) or Color3.fromRGB(45,45,45)
            end
        end
    end)
end

-- === Плавное открытие/закрытие меню ===
local menuOpen = false
openBtn.MouseButton1Click:Connect(function()
    menuOpen = not menuOpen
    slapMenu.Visible = true
    local tweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)
    local goal = {}
    if menuOpen then
        goal.BackgroundTransparency = 0.3
    else
        goal.BackgroundTransparency = 0.9
    end
    local tween = TweenService:Create(slapMenu, tweenInfo, goal)
    tween:Play()
    tween.Completed:Connect(function()
        if not menuOpen then
            slapMenu.Visible = false
        end
    end)
end)

-- УДАЛЕНИЕ ПРЕДЫДУЩЕГО GUI, если уже есть
local oldGui = player:WaitForChild("PlayerGui"):FindFirstChild("LuaGUI")
if oldGui then oldGui:Destroy() end

-- === GUI ===
local gui = Instance.new("ScreenGui")
gui.Name = "LuaGUI"
gui.ResetOnSpawn = false
gui.Parent = player:WaitForChild("PlayerGui")

-- === ИКОНКА ===
local iconSize = 60
local icon = Instance.new("Frame")
icon.Size = UDim2.new(0, iconSize, 0, iconSize)
icon.Position = UDim2.new(0.075, 0, 0.38, 0)
icon.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
icon.BackgroundTransparency = 0.4
icon.BorderSizePixel = 0
icon.Parent = gui

local iconCorner = Instance.new("UICorner")
iconCorner.CornerRadius = UDim.new(1, 0)
iconCorner.Parent = icon

local iconStroke = Instance.new("UIStroke")
iconStroke.Thickness = 2
iconStroke.Transparency = 0.5
iconStroke.Color = Color3.fromRGB(255, 255, 255)
iconStroke.Parent = icon

local iconText = Instance.new("TextLabel")
iconText.Size = UDim2.new(1, 0, 1, 0)
iconText.BackgroundTransparency = 1
iconText.Text = "PvP 0.6.7"
iconText.TextScaled = true
iconText.Font = Enum.Font.Arcade
iconText.TextColor3 = Color3.fromRGB(255, 255, 255)
iconText.Parent = icon

-- === ОКНО ===
local window = Instance.new("Frame")
window.Size = UDim2.new(0, 230, 0, 300)
window.Position = UDim2.new(0.5, 0, 0.5, 0)
window.AnchorPoint = Vector2.new(0.5, 0.5)
window.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
window.BackgroundTransparency = 0.15
window.Visible = false
window.Parent = gui

local winCorner = Instance.new("UICorner")
winCorner.CornerRadius = UDim.new(0.05, 0)
winCorner.Parent = window

local title = Instance.new("TextLabel")
title.Size = UDim2.new(1, 0, 0, 40)
title.Position = UDim2.new(0,0,0,0)
title.BackgroundTransparency = 1
title.Text = "PvP Menu Beta 0.6.7 NEED A GOOD PING FOR THE FUNCTIONS TO WORK PROPERLY"
title.Font = Enum.Font.Arcade
title.TextScaled = true
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.Parent = window

-- Контейнер для кнопок
local buttonsFrame = Instance.new("Frame")
buttonsFrame.Size = UDim2.new(1, 0, 1, -40)
buttonsFrame.Position = UDim2.new(0, 0, 0, 40)
buttonsFrame.BackgroundTransparency = 1
buttonsFrame.Parent = window

local layout = Instance.new("UIListLayout")
layout.Padding = UDim.new(0, 6)
layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
layout.VerticalAlignment = Enum.VerticalAlignment.Top
layout.Parent = buttonsFrame

-- === Вспомогательные таблицы ===
local buttons = {}        -- кнопки (TextButton)
local bindBoxes = {}      -- TextBox для биндов (только Big Ragdoll и Near Player)
local binds = {           -- хранение биндов (строка)
    ["Big Ragdoll 0.2"] = "",
    ["Near Player 1.3"] = ""
}

-- создать строку: кнопка + bind box (если нужно)
local function makeButtonRow(name, showBind)
    local row = Instance.new("Frame")
    row.Size = UDim2.new(0.95, 0, 0, 28)
    row.BackgroundTransparency = 1
    row.Parent = buttonsFrame

    local btn = Instance.new("TextButton")
    btn.Size = UDim2.new(0.74, 0, 1, 0)
    btn.Position = UDim2.new(0, 0, 0, 0)
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
    btn.AutoButtonColor = false
    btn.TextColor3 = Color3.fromRGB(255,255,255)
    btn.TextScaled = true
    btn.Font = Enum.Font.Arcade
    btn.Text = name
    btn.Parent = row

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0.18,0)
    corner.Parent = btn

    local bindBox = nil
    if showBind then
        bindBox = Instance.new("TextBox")
        bindBox.Size = UDim2.new(0.24, 0, 1, 0)
        bindBox.Position = UDim2.new(0.76, 0, 0, 0)
        bindBox.BackgroundColor3 = Color3.fromRGB(35,35,35)
        bindBox.TextColor3 = Color3.fromRGB(255,255,255)
        bindBox.ClearTextOnFocus = true
        bindBox.PlaceholderText = "Bind"
        bindBox.Font = Enum.Font.Arcade
        bindBox.TextScaled = true
        bindBox.Text = binds[name] or ""
        bindBox.Parent = row

        local bcorner = Instance.new("UICorner")
        bcorner.CornerRadius = UDim.new(0.18,0)
        bcorner.Parent = bindBox
    else
        -- пустая заплатка чтобы layout не ломался
        local spacer = Instance.new("Frame")
        spacer.Size = UDim2.new(0.24, 0, 1, 0)
        spacer.BackgroundTransparency = 1
        spacer.Position = UDim2.new(0.76, 0, 0, 0)
        spacer.Parent = row
    end

    return btn, bindBox
end

local buttonNames = {
    "HitBox Visible 0.4",
    "Speed Booster 0.3",
    "Big Ragdoll 0.2",
    "Near Player 1.3",
    "Auto Grab 0.1",
    "Hitboxes Near Player 0.2",
    "Button 7",
    "Button 8",
    "Button 9"
}

for _, name in ipairs(buttonNames) do
    local showBind = (name == "Big Ragdoll 0.2" or name == "Near Player 1.3")
    local btn, tb = makeButtonRow(name, showBind)
    buttons[name] = btn
    if tb then bindBoxes[name] = tb end
end

-- helper: визуализация статуса кнопки (зелёный = включено)
local function setButtonActiveVisual(name, on)
    local b = buttons[name]
    if not b then return end
    if on then
        b.BackgroundColor3 = Color3.fromRGB(0,170,0)
    else
        b.BackgroundColor3 = Color3.fromRGB(40,40,40)
    end
end

-- === SLAP MENU (кнопка слева от Near Player + выезжающее меню) ===
do
    -- список слэпов (имена моделей в Backpack/Character)
    local slapList = {
        "Glitched Slap",
        "Nuclear Slap",
        "Ruby Slap",
        "Diamod Slap",
        "Iron Slap",
        "Bat"
    }

    -- создаём маленькую кнопку, прилеплённую к строке Near Player
    local nearRowBtn = buttons["Near Player 1.2"]
    if nearRowBtn then
        local slapMenuButton = Instance.new("TextButton")
        slapMenuButton.Name = "SlapMenuBtn"
        slapMenuButton.Size = UDim2.new(0, 22, 0, 22)
        slapMenuButton.Position = UDim2.new(1, 6, 0.5, -11) -- справа от кнопки, но we'll position relative to window later
        slapMenuButton.AnchorPoint = Vector2.new(0, 0)
        slapMenuButton.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
        slapMenuButton.Text = "≡"
        slapMenuButton.TextScaled = true
        slapMenuButton.Font = Enum.Font.Arcade
        slapMenuButton.TextColor3 = Color3.fromRGB(255,255,255)
        slapMenuButton.Parent = nearRowBtn
    end

    -- плавающее меню (отдельное окно, не на window)
    local slapWindow = Instance.new("Frame")
    slapWindow.Name = "SlapWindow"
    slapWindow.Size = UDim2.new(0, 180, 0, 220)
    -- позиционируем чуть левее основного окна
    local windowScreenPos = window.AbsolutePosition
    slapWindow.Position = UDim2.new(0, windowScreenPos.X - 200, 0, windowScreenPos.Y)
    slapWindow.BackgroundColor3 = Color3.fromRGB(25,25,25)
    slapWindow.BorderSizePixel = 0
    slapWindow.Visible = false
    slapWindow.Parent = gui

    local swCorner = Instance.new("UICorner")
    swCorner.CornerRadius = UDim.new(0.05, 0)
    swCorner.Parent = slapWindow

    local swStroke = Instance.new("UIStroke")
    swStroke.Color = Color3.fromRGB(255,255,255)
    swStroke.Transparency = 0.85
    swStroke.Thickness = 1
    swStroke.Parent = slapWindow

    local header = Instance.new("TextLabel")
    header.Size = UDim2.new(1, 0, 0, 30)
    header.Position = UDim2.new(0,0,0,0)
    header.BackgroundTransparency = 1
    header.Text = "Slap Selector"
    header.Font = Enum.Font.Arcade
    header.TextSize = 16
    header.TextColor3 = Color3.fromRGB(255,255,255)
    header.Parent = slapWindow

    local listFrame = Instance.new("Frame")
    listFrame.Size = UDim2.new(1, -10, 1, -40)
    listFrame.Position = UDim2.new(0, 5, 0, 35)
    listFrame.BackgroundTransparency = 1
    listFrame.Parent = slapWindow

    local listLayout = Instance.new("UIListLayout")
    listLayout.Padding = UDim.new(0, 6)
    listLayout.FillDirection = Enum.FillDirection.Vertical
    listLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
    listLayout.VerticalAlignment = Enum.VerticalAlignment.Top
    listLayout.Parent = listFrame

    local function refreshSlapButtonsVisual()
        for _, c in ipairs(listFrame:GetChildren()) do
            if c:IsA("TextButton") then
                if c.Name == SelectedSlap then
                    c.BackgroundColor3 = Color3.fromRGB(0,170,0)
                    c.TextColor3 = Color3.fromRGB(0,0,0)
                else
                    c.BackgroundColor3 = Color3.fromRGB(40,40,40)
                    c.TextColor3 = Color3.fromRGB(255,255,255)
                end
            end
        end
    end

    for _, name in ipairs(slapList) do
        local b = Instance.new("TextButton")
        b.Name = name
        b.Size = UDim2.new(0, 160, 0, 32)
        b.BackgroundColor3 = Color3.fromRGB(40,40,40)
        b.Font = Enum.Font.Arcade
        b.TextScaled = true
        b.Text = name
        b.Parent = listFrame

        local bc = Instance.new("UICorner")
        bc.CornerRadius = UDim.new(0.12, 0)
        bc.Parent = b

        b.MouseEnter:Connect(function()
            if b.Name ~= SelectedSlap then
                b:TweenSize(UDim2.new(0, 164, 0, 34), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.08, true)
                b.BackgroundColor3 = Color3.fromRGB(55,55,55)
            end
        end)
        b.MouseLeave:Connect(function()
            if b.Name ~= SelectedSlap then
                b:TweenSize(UDim2.new(0, 160, 0, 32), Enum.EasingDirection.Out, Enum.EasingStyle.Quad, 0.08, true)
                b.BackgroundColor3 = Color3.fromRGB(40,40,40)
            end
        end)

        b.MouseButton1Click:Connect(function()
            SelectedSlap = name
            refreshSlapButtonsVisual()
        end)
    end

    -- make slapWindow draggable (custom)
    do
        local dragging = false
        local dragStart = Vector2.new()
        local startPos = slapWindow.Position

        slapWindow.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                dragging = true
                dragStart = input.Position
                startPos = slapWindow.Position
                input.Changed:Connect(function()
                    if input.UserInputState == Enum.UserInputState.End then
                        dragging = false
                    end
                end)
            end
        end)
        UserInputService.InputChanged:Connect(function(input)
            if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
                local delta = input.Position - dragStart
                slapWindow.Position = UDim2.new(
                    startPos.X.Scale, startPos.X.Offset + delta.X,
                    startPos.Y.Scale, startPos.Y.Offset + delta.Y
                )
            end
        end)
    end

    -- toggle animation (show/hide)
    local menuOpen = false
    if nearRowBtn and nearRowBtn:FindFirstChild("SlapMenuBtn") then
        local trigger = nearRowBtn:FindFirstChild("SlapMenuBtn")
        trigger.MouseButton1Click:Connect(function()
            menuOpen = not menuOpen
            if menuOpen then
                slapWindow.Visible = true
                -- move to near the main window but slightly left
                local target = UDim2.new(0, window.AbsolutePosition.X - slapWindow.Size.X.Offset - 12, 0, window.AbsolutePosition.Y)
                slapWindow:TweenPosition(target, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.25, true)
            else
                slapWindow:TweenPosition(UDim2.new(0, -1000, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.22, true)
                task.delay(0.22, function() slapWindow.Visible = false end)
            end
        end)
    end
end

-- === HITBOX Visible + NearPlayer зона (один прямоугольник) ===
do
    local PlayersSvc = Players
    local Local = player
    local hitboxVisible = false

    -- NearPlayer зона
    local nearPart

    -- создание обычного хитбокса и подсветки
    local function createHitboxESP(char)
        local hitbox = char:FindFirstChild("__HITBOX")
        if hitbox and hitbox:IsA("BasePart") then
            if not hitbox:FindFirstChild("HitboxHighlight") then
                local hl = Instance.new("Highlight")
                hl.Name = "HitboxHighlight"
                hl.Adornee = hitbox
                hl.FillColor = Color3.fromRGB(0,0,0)
                hl.OutlineColor = Color3.fromRGB(255,255,255)
                hl.FillTransparency = 0.5
                hl.OutlineTransparency = 0
                hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
                hl.Parent = hitbox
            end
            hitbox.Transparency = 0.5
            hitbox.CanCollide = false
        end
    end

    -- обновление всех хитбоксов
    local function updateHitboxes()
        for _, plr in ipairs(PlayersSvc:GetPlayers()) do
            if plr ~= Local and plr.Character then
                createHitboxESP(plr.Character)
            end
        end
    end

    -- toggle кнопка
    local toggleBtn = buttons["HitBox Visible 0.4"]
    toggleBtn.MouseButton1Click:Connect(function()
        hitboxVisible = not hitboxVisible
        if hitboxVisible then
            updateHitboxes()
        else
            if nearPart then nearPart:Destroy() nearPart = nil end
        end
        setButtonActiveVisual("HitBox Visible 0.4", hitboxVisible)
    end)
    setButtonActiveVisual("HitBox Visible 0.4", false)

    -- Heartbeat для динамики NearPlayer зоны
    RunService.Heartbeat:Connect(function()
        if hitboxVisible then
            -- try to call updateNearHitbox if exists
            pcall(function() if updateNearHitbox then updateNearHitbox() end end)
        end
    end)

    -- автоматическое добавление при появлении нового игрока
    PlayersSvc.PlayerAdded:Connect(function(plr)
        plr.CharacterAdded:Connect(function()
            task.wait(0.5)
            if hitboxVisible then
                updateHitboxes()
            end
        end)
    end)
end

-- === Speed Booster ===
do
    local speedBtn = buttons["Speed Booster 0.3"]
    local speedActive = false
    local speedConn = nil
    local baseSpeed = 27

    local function getChar()
        return player.Character
    end

    local function startSpeed()
        if speedConn then return end
        speedConn = RunService.Heartbeat:Connect(function()
            local char = getChar()
            if not char then return end
            local hrp = char:FindFirstChild("HumanoidRootPart")
            local hum = char:FindFirstChildOfClass("Humanoid")
            if not hrp or not hum then return end
            local move = hum.MoveDirection
            if move.Magnitude > 0.01 then
                hrp.AssemblyLinearVelocity = Vector3.new(move.Unit.X*baseSpeed, hrp.AssemblyLinearVelocity.Y, move.Unit.Z*baseSpeed)
            else
                hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
            end
        end)
    end

    local function stopSpeed()
        if speedConn then speedConn:Disconnect() speedConn = nil end
        local char = getChar()
        if char and char:FindFirstChild("HumanoidRootPart") then
            local hrp = char.HumanoidRootPart
            hrp.AssemblyLinearVelocity = Vector3.new(0, hrp.AssemblyLinearVelocity.Y, 0)
        end
    end

    speedBtn.MouseButton1Click:Connect(function()
        speedActive = not speedActive
        if speedActive then
            startSpeed()
        else
            stopSpeed()
        end
        setButtonActiveVisual("Speed Booster 0.3", speedActive)
    end)
    setButtonActiveVisual("Speed Booster 0.3", false)
end

-- === Перетаскивание окна (таскается за любую часть окна) ===
do
    local dragging = false
    local dragStart = Vector2.new()
    local startPos = window.Position

    window.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = window.Position
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
            local delta = input.Position - dragStart
            window.Position = UDim2.new(
                startPos.X.Scale,
                startPos.X.Offset + delta.X,
                startPos.Y.Scale,
                startPos.Y.Offset + delta.Y
            )
        end
    end)
end

-- === Big Ragdoll логика ===
local bigEnabled = false
local bigBtn = buttons["Big Ragdoll 0.2"]

local function performRagdollHit()
    local character = player.Character
    if not character then return end
    local backpack = player:FindFirstChild("Backpack") or player:WaitForChild("Backpack")
    local bat = backpack:FindFirstChild("Bat") or character:FindFirstChild("Bat")
    local glitch = backpack:FindFirstChild("Glitched Slap") or character:FindFirstChild("Glitched Slap")
    if not bat or not glitch then return end

    if bat.Parent == character then
        bat.Parent = backpack
    end
    glitch.Parent = character

    if glitch:FindFirstChild("Activate") then
        glitch.Activate:Fire()
    else
        pcall(function() glitch:Activate() end)
    end

    task.delay(0.005, function()
        if glitch.Parent == character then
            glitch.Parent = backpack
        end
        if bat.Parent ~= character then
            bat.Parent = character
        end
    end)
end

bigBtn.MouseButton1Click:Connect(function()
    bigEnabled = not bigEnabled
    setButtonActiveVisual("Big Ragdoll 0.2", bigEnabled)
end)

-- Клик мыши: если bigEnabled и Near Player не подавляет — делаем performRagdollHit
local function isNearPlayerSuppressing()
    local nearActive = (buttons["Near Player 1.3"] and (buttons["Near Player 1.3"].BackgroundColor3 == Color3.fromRGB(0,170,0)))
    if not nearActive then return false end
    -- проверяем цель перед игроком в 10 студий (угол ±45°)
    local char = player.Character
    if not char then return false end
    local head = char:FindFirstChild("Head")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not head or not hrp then return false end
    local origin = hrp.Position
    local look = head.CFrame.LookVector
    for _, pl in pairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            local targetPos = pl.Character.HumanoidRootPart.Position
            local toTarget = targetPos - origin
            if toTarget.Magnitude <= 8 then
                local angle = math.acos(math.clamp(look:Dot(toTarget.Unit), -1, 1))
                if angle <= math.rad(45) then
                    return true
                end
            end
        end
    end
    return false
end

local mouse = player:GetMouse()
mouse.Button1Down:Connect(function()
    if bigEnabled and not isNearPlayerSuppressing() then
        performRagdollHit()
    end
end)
-- Лаг-компенсация позиции игрока
local function GetPredictedPosition(character)
    if not character then return nil end

    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    -- текущее движение
    local vel = hrp.AssemblyLinearVelocity  

    -- твой реальный пинг
    local ping = game:GetService("Stats").Network.ServerStatsItem["Data Ping"]:GetValue() / 1000  
    -- ping 120 = 0.12 сек

    -- предсказанная позиция
    local predicted = hrp.Position + vel * ping

    return predicted
end
-- === Near Player + 2 хитбокса (трапеция) + отдельная кнопка Show Hitboxes ===

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local player = Players.LocalPlayer

local nearEnabled = false
local showHitboxes = false

-- кнопки
local nearBtn = buttons["Near Player 1.3"]
local showBtn = buttons["Hitboxes Near Player 0.2"]  -- ОТДЕЛЬНАЯ КНОПКА

local lastNearHit = 0

local partFront
local partBack

local FRONT_SIZE = Vector3.new(10, 10, 8)
local BACK_SIZE  = Vector3.new(6, 10, 6)


---------------------------------------------------------
--                УДАР ПО ИГРОКУ
---------------------------------------------------------
local function hitNearbyInvisible(plr)
    local now = tick()
    if now - lastNearHit < 0.8 then return end
    lastNearHit = now

    local char = player.Character
    local targetChar = plr.Character
    if not char or not targetChar then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    local humanoid = char:FindFirstChild("Humanoid")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")

    if not hrp or not humanoid or not targetHRP then return end

    -- поворот (фиксим ShiftLock)
    local dir = (targetHRP.Position - hrp.Position)
    local yaw = math.atan2(-dir.X, -dir.Z)

    local oldCF = hrp.CFrame
    humanoid.AutoRotate = false
    hrp.CFrame = CFrame.new(hrp.Position) * CFrame.Angles(0, yaw, 0)

    -- Слап
    local backpack = player.Backpack
    local bat = backpack:FindFirstChild("Bat") or char:FindFirstChild("Bat")
    local glitch = backpack:FindFirstChild(SelectedSlap) or char:FindFirstChild(SelectedSlap)
    if not bat or not glitch then return end

    glitch.Parent = char
    if glitch:FindFirstChild("Activate") then
        glitch.Activate:Fire()
    else
        pcall(function() glitch:Activate() end)
    end
    glitch.Parent = backpack

    if bat.Parent ~= char then
        bat.Parent = char
    end

    -- вернуть поворот
    task.delay(0.05, function()
        if humanoid and hrp then
            hrp.CFrame = oldCF
            humanoid.AutoRotate = true
        end
    end)
end


---------------------------------------------------------
--             СОЗДАНИЕ ХИТБОКСОВ
---------------------------------------------------------
local function createParts()
    if not partFront then
        partFront = Instance.new("Part")
        partFront.Anchored = true
        partFront.CanCollide = false
        partFront.CanQuery = false
        partFront.Size = FRONT_SIZE
        partFront.Material = Enum.Material.Neon
        partFront.Color = Color3.fromRGB(0,255,0)
        partFront.Transparency = 1
        partFront.Parent = workspace
    end

    if not partBack then
        partBack = Instance.new("Part")
        partBack.Anchored = true
        partBack.CanCollide = false
        partBack.CanQuery = false
        partBack.Size = BACK_SIZE
        partBack.Material = Enum.Material.Neon
        partBack.Color = Color3.fromRGB(0,180,0)
        partBack.Transparency = 1
        partBack.Parent = workspace
    end
end


---------------------------------------------------------
--            ОБНОВЛЕНИЕ ПОЗИЦИЙ ХИТБОКСОВ
---------------------------------------------------------
local function updateParts()
    if not nearEnabled then
        if partFront then partFront:Destroy() partFront = nil end
        if partBack then partBack:Destroy() partBack = nil end
        return
    end

    createParts()

    local char = player.Character
    if not char then return end

    local hrp = char:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

    local forward = hrp.CFrame.LookVector

    -- маленький спереди
    partFront.CFrame = CFrame.new(
        hrp.Position + forward * 3,
        hrp.Position + forward * 50
    )

    -- большой сзади
    partBack.CFrame = CFrame.new(
        hrp.Position + forward * 7,
        hrp.Position + forward * 50
    )
end


---------------------------------------------------------
--               ПОКАЗ / СКРЫТИЕ ХИТБОКСОВ
---------------------------------------------------------
local function updateHitboxVisibility()
    if partFront then
        partFront.Transparency = showHitboxes and 0.3 or 1
    end

    if partBack then
        partBack.Transparency = showHitboxes and 0.3 or 1
    end
end


---------------------------------------------------------
--                 ПРОВЕРКА ИГРОКОВ
---------------------------------------------------------
local function checkZone(plr, zonePart)
    local hrp = plr.Character and plr.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return false end

    local pos = hrp.Position
    local cf = zonePart.CFrame
    local size = zonePart.Size / 2

    local rel = cf:PointToObjectSpace(pos)

    return (
        math.abs(rel.X) <= size.X and
        math.abs(rel.Y) <= size.Y and
        math.abs(rel.Z) <= size.Z
    )
end

local function checkPlayers()
    if not nearEnabled then return end
    if not partFront and not partBack then return end

    for _, pl in ipairs(Players:GetPlayers()) do
        if pl ~= player and pl.Character and pl.Character:FindFirstChild("HumanoidRootPart") then
            if (partFront and checkZone(pl, partFront))
            or (partBack and checkZone(pl, partBack)) then
                hitNearbyInvisible(pl)
            end
        end
    end
end


---------------------------------------------------------
--                   КНОПКИ
---------------------------------------------------------
nearBtn.MouseButton1Click:Connect(function()
    nearEnabled = not nearEnabled
    setButtonActiveVisual("Near Player 1.3", nearEnabled)

    if not nearEnabled then
        if partFront then partFront:Destroy() partFront = nil end
        if partBack then partBack:Destroy() partBack = nil end
    end
end)

showBtn.MouseButton1Click:Connect(function()
    showHitboxes = not showHitboxes
    setButtonActiveVisual("Show Hitboxes 0.2", showHitboxes)
    updateHitboxVisibility()
end)


---------------------------------------------------------
--                 HEARTBEAT
---------------------------------------------------------
RunService.Heartbeat:Connect(function()
    if nearEnabled then
        updateParts()
        checkPlayers()
    end

    updateHitboxVisibility()
end)

-- === BIND handling (TextBoxes + Enter to set / key toggles) ===
do
    local typing = false
    local activeTextBox = nil

    local function normalizeBindText(s)
        if not s then return "" end
        s = tostring(s):gsub("^%s*(.-)%s*$", "%1") -- trim
        return s:upper()
    end

    -- Setup TextBoxes behavior
    for name, tb in pairs(bindBoxes) do
        tb.FocusLost:Connect(function(enterPressed)
            typing = false
            activeTextBox = nil
            if enterPressed then
                local txt = normalizeBindText(tb.Text)
                -- принять пустой – очистить
                binds[name] = txt
                tb.Text = txt
            else
                tb.Text = binds[name] or ""
            end
        end)

        tb.Focused:Connect(function()
            typing = true
            activeTextBox = tb
            tb.Text = ""
        end)
    end

    -- НАДЁЖНОЕ InputBegan без глюков
    UserInputService.InputBegan:Connect(function(input, gameProcessed)
        if typing then return end
        if input.UserInputType ~= Enum.UserInputType.Keyboard then return end

        -- ЧИСТОЕ ИМЯ КЛАВИШИ
        local keyName = input.KeyCode.Name:upper()
        if not keyName or keyName == "" then return end

        -- Перебираем все действия
        for actionName, bindStr in pairs(binds) do
            if bindStr and bindStr ~= "" then
                local norm = normalizeBindText(bindStr)

                -- Чёткое совпадение
                if norm == keyName then
                    if actionName == "Big Ragdoll 0.2" then
                        bigEnabled = not bigEnabled
                        setButtonActiveVisual("Big Ragdoll 0.2", bigEnabled)

                    elseif actionName == "Near Player 1.3" then
                        nearEnabled = not nearEnabled
                        setButtonActiveVisual("Near Player 1.3", nearEnabled)
                    end
                end
            end
        end
    end)
end

-- === Инициализация визуалок (везде нейтральный цвет, активные будут зелёными) ===
for name, btn in pairs(buttons) do
    btn.BackgroundColor3 = Color3.fromRGB(40,40,40)
end
setButtonActiveVisual("HitBox Visible 0.4", false)
setButtonActiveVisual("Speed Booster 0.3", false)
setButtonActiveVisual("Big Ragdoll 0.2", false)
setButtonActiveVisual("Near Player 1.3", false)

-- === Иконка и открытие окна ===
icon.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 then
        -- toggle window visibility
        if window.Visible then
            window:TweenSizeAndPosition(UDim2.new(0,0,0,0), window.Position, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.18, true)
            task.wait(0.18)
            window.Visible = false
        else
            window.Visible = true
            window.Size = UDim2.new(0,0,0,0)
            window:TweenSizeAndPosition(UDim2.new(0,230,0,300), UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.22, true)
        end
    end
end)

-- RightShift toggle also works
UserInputService.InputBegan:Connect(function(input, processed)
    if not processed and input.KeyCode == Enum.KeyCode.RightShift then
        if window.Visible then
            window:TweenSizeAndPosition(UDim2.new(0,0,0,0), window.Position, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.18, true)
            task.wait(0.18)
            window.Visible = false
        else
            window.Visible = true
            window.Size = UDim2.new(0,0,0,0)
            window:TweenSizeAndPosition(UDim2.new(0,230,0,300), UDim2.new(0.5,0,0.5,0), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.22, true)
        end
    end
end)
local autoGrab = false
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local lp = Players.LocalPlayer

local function getCharacter()
	local char = lp.Character or lp.CharacterAdded:Wait()
	return char, char:WaitForChild("HumanoidRootPart")
end

buttons["Auto Grab 0.1"].MouseButton1Click:Connect(function()
	autoGrab = not autoGrab
	setButtonActiveVisual("Auto Grab 0.1", autoGrab)
end)


-- Функция: нормальное зажатие Prompt-а
local function holdPrompt(prompt)
	-- ждем 0.1с после появления
	task.wait(0.5413423412432431234)

	-- Настоящее зажатие
	pcall(function()
		prompt:InputHoldBegin()
		task.wait(prompt.HoldDuration or 2) -- если HoldDuration = 3, подстраиваемся
		prompt:InputHoldEnd()
	end)
end


RunService.Heartbeat:Connect(function()
	if not autoGrab then return end

	local char, hrp = getCharacter()
	if not hrp then return end

	local plotsFolder = workspace:FindFirstChild("Plots")
	if not plotsFolder then return end

	for _, plot in ipairs(plotsFolder:GetChildren()) do
		local podiums = plot:FindFirstChild("AnimalPodiums")
		if podiums then
			for _, podium in ipairs(podiums:GetChildren()) do
				local base = podium:FindFirstChild("Base")
				if base then
					local spawnPart = base:FindFirstChild("Spawn")
					if spawnPart then
						local attach = spawnPart:FindFirstChild("PromptAttachment")
						if attach then
							
							for _, prompt in ipairs(attach:GetChildren()) do
								if prompt:IsA("ProximityPrompt")
								and prompt.Enabled
								and string.lower(prompt.ActionText) == "steal" then -- ИЩЕМ STEAL

									-- Проверяем расстояние
									local dist = (hrp.Position - spawnPart.Position).Magnitude
									if dist <= prompt.MaxActivationDistance then

										-- Запускаем в отдельном потоке,
										-- чтобы не ломать Heartbeat
										task.spawn(function()
											holdPrompt(prompt)
										end)

									end
								end
							end
							
						end
					end
				end
			end
		end
	end
end)

